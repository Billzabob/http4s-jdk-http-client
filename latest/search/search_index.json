{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"http4s-jdk-http-client"},{"location":"/index.html#http4s-jdk-http-client","text":"http4s-jdk-http-client is a http4s-client implementation based on the java.net.http.HttpClient introduced in Java 11.","title":"http4s-jdk-http-client"},{"location":"/index.html#installation","text":"To use http4s-jdk-http-client in an existing SBT project, add the following dependency to your build.sbt:\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-jdk-http-client\" % \"0.2.0-SNAPSHOT\"\n)","title":"Installation"},{"location":"/index.html#compatibility","text":"Requires Java 11 or greater Built for Scala 2.12 Works with http4s-client-0.21.0-M1.x","title":"Compatibility"},{"location":"/index.html#creating-the-client","text":"","title":"Creating the client"},{"location":"/index.html#simple","text":"A default JDK HTTP client can be created with a call to simple for any ConcurrentEffect type, such as cats.effect.IO:\nimport cats.effect.IO\nimport org.http4s.client.Client\nimport org.http4s.client.jdkhttpclient.JdkHttpClient\n\n// A `Timer` and `ContextShift` are necessary for a `ConcurrentEffect[IO]`.\n// They come for free when you use `cats.effect.IOApp`:\nimport cats.effect.{ContextShift, Timer}\nimport scala.concurrent.ExecutionContext.Implicits.global\nimplicit val timer: cats.effect.Timer[IO] = IO.timer(global)\nimplicit val cs: cats.effect.ContextShift[IO] = IO.contextShift(global)\n\nval client: IO[Client[IO]] = JdkHttpClient.simple[IO]","title":"Simple"},{"location":"/index.html#custom-clients","text":"A JDK HTTP client can be passed to JdkHttpClient.apply for use as an http4s-client backend. It is a good idea to create the HttpClient in an effect, as it creates a default executor and SSL context:\nimport java.net.{InetSocketAddress, ProxySelector}\nimport java.net.http.HttpClient\n\nval client0: IO[Client[IO]] = IO {\n  HttpClient.newBuilder()\n    .version(HttpClient.Version.HTTP_2)\n    .proxy(ProxySelector.of(new InetSocketAddress(\"www-proxy\", 8080)))\n    .build()\n}.map(JdkHttpClient(_))","title":"Custom clients"},{"location":"/index.html#sharing","text":"The client instance contains shared resources such as a connection pool, and should be passed as an argument to code that uses it:\nimport cats.effect._\nimport cats.implicits._\nimport org.http4s._\n  \ndef fetchStatus[F[_]](c: Client[F], uri: Uri): F[Status] =\n  c.status(Request[F](Method.GET, uri = uri))\n\nclient\n  .flatMap(c => fetchStatus(c, uri\"https://http4s.org/\"))\n  .attempt\n  .unsafeRunSync()\n// res0: Either[Throwable, Status] = Right(Status(200))\nFailure to share Contrast with this alternate definition of fetchStatus, which would create a new HttpClient instance on every invocation: def fetchStatusInefficiently[F[_]: ConcurrentEffect](uri: Uri): F[Status] =\n  JdkHttpClient.simple[F].flatMap(_.status(Request[F](Method.GET, uri = uri)))","title":"Sharing"},{"location":"/index.html#shutdown","text":"Clients created with this back end do not need to be shut down.","title":"Shutdown"},{"location":"/index.html#further-reading","text":"For more details on the http4s-client, please see the [core client documentation][client].","title":"Further reading"}]}